// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract DynamicNFT is ERC721, ERC721URIStorage, Ownable, ERC721Burnable {

 using Counters for Counters.Counter;
 Counters.Counter private _tokenIdCounter;

 string[] IpfsUri = [
     "ipfs://Qme47kKiiC5Crhn1wniwxk2DTKMKTSoRrz8UyxmLLmSiT5/stage 1.json",
     "ipfs://Qme47kKiiC5Crhn1wniwxk2DTKMKTSoRrz8UyxmLLmSiT5/stage 2.json",
     "ipfs://Qme47kKiiC5Crhn1wniwxk2DTKMKTSoRrz8UyxmLLmSiT5/stage 3.json",
     "ipfs://Qme47kKiiC5Crhn1wniwxk2DTKMKTSoRrz8UyxmLLmSiT5/stage 4.json"
 ];
 
 uint256 lastTimeStamp;
 uint256 interval;
 
 constructor(uint256 _interval) ERC721("Dynamic NFTs", "dNFT") Ownable(msg.sender) {
    interval = _interval;
    lastTimeStamp = block.timestamp;
 }
 
 function checkUpkeep(bytes calldata /* checkData */) external view  returns (bool upkeepNeeded /* performData */) {
     upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
     // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
 }
 
 function performUpkeep(bytes calldata /* performData */) external  {
     // We highly recommend revalidating the upkeep in the performUpkeep function
     if ((block.timestamp - lastTimeStamp) > interval ) {
         lastTimeStamp = block.timestamp;
         levelUp(0);
     }
     // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
 }
 
 function levelUp(uint256 _tokenId) public {
     if(currentStage(_tokenId) >= 3){return;}
     // Get the current stage of the flower and add 1
     uint256 newVal = currentStage(_tokenId) + 1;
     // store the new URI
     string memory newUri = IpfsUri[newVal];
     // Update the URI
     _setTokenURI(_tokenId, newUri);
 }
 
 // Determine the stage of the flower growth
 function currentStage(uint256 _tokenId) public view returns (uint256) {
     string memory _uri = tokenURI(_tokenId);
     // Stage 1
     if (compareStrings(_uri, IpfsUri[0])) {
         return 0;
     }
     // Stage 2
     if (
         compareStrings(_uri, IpfsUri[1])
     ) {
         return 1;
     }
     // Stage 3
     if (
         compareStrings(_uri, IpfsUri[2])
     ) {
         return 2;
     }
     // Must be Stage 4
     return 3;
 }
 
 // helper function to compare strings
 function compareStrings(string memory a, string memory b) public pure returns (bool)
 {
     return (keccak256(abi.encodePacked((a))) ==
         keccak256(abi.encodePacked((b))));
 }
 
 function safeMint(address to) public {
      uint256 tokenId = _tokenIdCounter.current();
      _tokenIdCounter.increment();
      _safeMint(to, tokenId);
      _setTokenURI(tokenId, IpfsUri[0]);
  }

 function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory)
 {
     return super.tokenURI(tokenId);
 }

 function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721URIStorage) returns (bool) {
    return super.supportsInterface(interfaceId);
 }

}
